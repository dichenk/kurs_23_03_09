- Рассылки проводятся при поддержке приложения django-apscheduler. 
Для запуска в отдельном окне терминала необходимо выполнить команду python manage.py runapscheduler. Логика работы приложения: раз в 
60 секунд (настройка в settings.py) осуществляется запрос в бд. Все письма с истекшей датой и временем отправки уходят в рассылку, дата следующей
отправки изменяется в соответствии с периодичностью. Код: app_spammy->management->commands->runappscheduler.py

- Расширьте модель пользователя для регистрации по почте, а также верификации
  - Модель пользователя реализована в приложении app_users. Users(AbstractUser). 
  - реализована регистрация по почте (views->UsersCreateView->form_valid()), верификация (views->activate_email())
- Добавьте интерфейс для входа, регистрации и подтверждения почтового ящика
  - http://127.0.0.1:8000/users/login/
  - http://127.0.0.1:8000/users/register/
  - 
- Реализуйте ограничение доступа к рассылкам для разных пользователей
  - Доступ к рассылкам возможен только у авторов рассылок. Ограничение реализовано через get_queryset в app_spammy->NewsletterListView - фильтр Newsletter.objects.filter(author=self.request.user).order_by('pk')
- Реализуйте интерфейс менеджера
  - Интерфейс менеджера реализован на главной странице через тег формата через теги формата {% if request.user|has_group:"manager" %}
- Создайте блог для продвижения сервиса

### Функционал менеджера

- **может** просматривать любые рассылки
  - http://127.0.0.1:8000/maillist/newsletter
- **может** просматривать список пользователей сервиса
  - http://127.0.0.1:8000/users/users/
- **может** блокировать пользователей сервиса
  - ссылка "забанить" на странице списка пользователей
- **может** отключать рассылки
  - ссылка "disable maillist" на странице просмотра рассылок
- **не может** редактировать рассылки
  - возможность редактирования рассылки существует только у автора
- **не может** управлять списком рассылок
- **не может** изменять рассылки и сообщения 
  - возможность изменения рассылок и сообщений существует только у автора


### Функционал пользователя

Весь функционал дублируется из старой версии, но теперь нужно следить за тем, чтобы пользователь не мог случайным образом изменить чужую рассылку и мог работать только со своим списком клиентов и со своим списком рассылок.
 - реализовано через фильтр Newsletter.objects.filter(author=self.request.user) в функции get_queryset(self)

Реализуйте приложение для ведения блога.
http://127.0.0.1:8000/blog/list
Содержит:
- заголовок
- содержимое статьи
- изображение
- количество просмотров
- дата публикации


### Главная страница
Реализуйте главную страницу в произвольном формате, но обязательно отобразите следующую информацию:
Главная страница реализована отдельным приложением.
- количество рассылок всего
- количество активных рассылок
- количество уникальных клиентов для рассылок
- 3 случайные статьи из блога

Для блога и главной страницы самостоятельно выберите какие данные необходимо кешировать, а также каким способом необходимо произвести кеширование.

- [ ]  Все интерфейсы, не относящиеся к стандартной админке, для изменения и создания сущностей необходимо реализовать с помощью Django форм
  - интерфейсы реализованы с помощью Django форм с применением crispy
- [ ]  Все настройки прав доступа реализованы верно
  - Неавторизованному пользователю доступна только главная страница, страница регистрации (реализовано через LoginRequiredMixin во views). Доступ к информации в шаблоне (меню) осуществляется через теги формата {% if request.user|has_group:"news_author" %}.

- [ ]  Использовано как минимум два типа кеширования
  - Реализовано кэширование на уровне представлений (смотри app_spammy->urls.py), а также кэширование фрагментов шаблона (смотри app_spammy->templates->app_spammy->mail_list)